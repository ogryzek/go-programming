# Section 8 Grouping - 8.07 Slice - Make
    
If the go ref, under [Slice Types](https://golang.org/ref/spec#Slice_types), we can see that `make` is a built-in function, which takes a slice type and parameters specifying the length of hte array beyond the slice, e.g. `make([]T, length, capacity)`.  
  
So, what does that mean? Basically, a slice is built on top of an array. Slices are dynamic, in that they can change in size; their size is dynamic. When you create a slice, it's sitting on top of an array. If the slice grows, a new array has to be created, and all the values copied into the new array. The old array is then thrown away. This takes some processing power, so if you already know the size of how many elements you are going to store, you can use `make` to automatically _make_ that underlying array a big enough size to hold all the values you want to put into it, and therefore save the extra time and effort that the compiler goes through, that the runtime goes through to change that underlying array, copying all the values into a new array, and throw away the old one, so you have a bigger array to hold all the values, as your slice grows.  
  
Simply, if you know that you need an array of a certain size, you can use `make` to build that.  
  
So, let's say we want to _make_ an array of type `int` with a length of 10 and capacity of 100 (the same example as [effective go](https://golang.org/doc/effective_go.html#allocation_make) uses):  
  
```go
package main

import (
	"fmt"
)

func main() {
	x := make([]int, 10, 100)
	fmt.Println(x)
	fmt.Println(len(x))
	fmt.Println(cap(x))
}

```
[playground](https://play.golang.org/p/3-lz0nHg5-U)  
  
To better understand length and capacity, let's try some different numbers as examples

```go
packain main

import (
	"fmt"
)

func main() {
	x := make([]int, 10, 12)
	fmt.Println(x)
	fmt.Println(len(x))
	fmt.Println(cap(x))

	x[9] = 10
	x = append(x, 11)
	x = append(x, 12)
	fmt.Println(x)
	fmt.Println(len(x))
	fmt.Println(cap(x))


	x = append(x, 13)
	x = append(x, 14)
	fmt.Println(x)
	fmt.Println(len(x))
	fmt.Println(cap(x))
}

```
[playground](https://play.golang.org/p/2FRq9LdAR3C)   

Here we can see the length of the array grows from 10 to 12, as we append 2 elements. When we append more elements beyond 12, the underlying array grows by an additional 12. This shows that the compiler is creating a new array, increasing the capacity by the capacity specified (from 12 to 24), then copying over the values from the current array, and throwing it away.  

